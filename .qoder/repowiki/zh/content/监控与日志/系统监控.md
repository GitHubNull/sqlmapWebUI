# 系统监控

<cite>
**本文档引用的文件**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [main.py](file://src/backEnd/main.py)
- [config.py](file://src/backEnd/config.py)
- [DataStore.py](file://src/backEnd/model/DataStore.py)
- [Task.py](file://src/backEnd/model/Task.py)
- [TaskStatus.py](file://src/backEnd/model/TaskStatus.py)
- [taskService.py](file://src/backEnd/service/taskService.py)
</cite>

## 目录
1. [简介](#简介)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [架构概述](#架构概述)
5. [详细组件分析](#详细组件分析)
6. [依赖分析](#依赖分析)
7. [性能考虑](#性能考虑)
8. [故障排除指南](#故障排除指南)
9. [结论](#结论)

## 简介
本文档详细解析了SQLMapWebUI项目中的系统监控机制。重点分析了任务监控器的实现原理，包括监控循环的调度、任务状态轮询逻辑以及自动处理策略。文档还说明了监控服务的初始化流程、关键性能指标的采集方法、系统的可配置性以及为运维人员提供的实用诊断指南。

## 项目结构
项目采用分层架构，主要模块包括API接口、模型定义、服务逻辑和工具函数。监控相关的核心文件位于`utils`目录下的`task_monitor.py`，监控服务的初始化在`main.py`中完成。

```mermaid
graph TD
subgraph "src/backEnd"
subgraph "utils"
task_monitor[task_monitor.py]
auth[auth.py]
header_processor[header_processor.py]
session_header_manager[session_header_manager.py]
end
subgraph "model"
DataStore[DataStore.py]
Task[Task.py]
TaskStatus[TaskStatus.py]
Database[Database.py]
end
subgraph "service"
taskService[taskService.py]
headerRuleService[headerRuleService.py]
end
main[main.py]
app[app.py]
config[config.py]
subgraph "third_lib"
sqlmap[sqlmap]
end
end
main --> task_monitor
main --> config
task_monitor --> DataStore
task_monitor --> Task
task_monitor --> TaskStatus
taskService --> DataStore
taskService --> Task
taskService --> TaskStatus
```

**图表来源**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [main.py](file://src/backEnd/main.py)
- [DataStore.py](file://src/backEnd/model/DataStore.py)

**章节来源**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [main.py](file://src/backEnd/main.py)

## 核心组件
系统监控的核心组件包括任务监控器、任务状态管理器和任务服务。任务监控器负责定期检查任务状态并启动可运行的任务，任务状态管理器定义了任务的生命周期，任务服务提供了对任务的增删改查操作。

**章节来源**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [Task.py](file://src/backEnd/model/Task.py)
- [TaskStatus.py](file://src/backEnd/model/TaskStatus.py)

## 架构概述
系统采用基于APScheduler的定时任务监控架构，通过后台调度器定期执行监控函数。监控函数检查任务队列中的任务状态，根据系统负载动态调整最大并发任务数，并启动符合条件的任务。

```mermaid
sequenceDiagram
participant Scheduler as "APScheduler"
participant Monitor as "任务监控器"
participant DataStore as "数据存储"
participant Task as "任务"
Scheduler->>Monitor : 每3秒执行一次
Monitor->>DataStore : 获取任务锁
Monitor->>DataStore : 获取最大任务数
Monitor->>DataStore : 遍历所有任务
loop 任务状态检查
DataStore->>Task : 获取任务状态
alt 任务可运行
Task->>Monitor : 添加到可运行列表
else 任务正在运行
Task->>Monitor : 检查进程是否终止
alt 进程已终止
Task->>Task : 状态设为Terminated
end
end
end
Monitor->>Monitor : 检查运行中任务数
alt 有空闲容量
loop 启动可运行任务
Monitor->>Task : 启动任务
Task->>Task : 设置状态为Running
end
end
```

**图表来源**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [main.py](file://src/backEnd/main.py)

## 详细组件分析

### 任务监控器分析
任务监控器是系统监控的核心，负责任务的调度和状态管理。

#### 任务监控类图
```mermaid
classDiagram
class TaskMonitor {
+monitor(max_tasks_count)
+get_max_tasks_count()
}
class DataStore {
+tasks : OrderedDict
+tasks_lock : Lock
+max_tasks_count : int
+max_tasks_count_lock : Lock
+first_checkin_monitor : bool
+get_session_header_manager()
}
class Task {
+status : TaskStatus
+start_datetime : datetime
+taskid : str
+scanUrl : str
+host : str
+headers : list
+body : str
+remote_addr : str
+process : Popen
+options : AttribDict
+_header_rules_applied : bool
+engine_start()
+engine_stop()
+engine_kill()
+engine_has_terminated()
+apply_header_rules()
}
class TaskStatus {
+New : "New"
+Runnable : "Runnable"
+Running : "Running"
+Blocked : "Blocked"
+Terminated : "Terminated"
}
TaskMonitor --> DataStore : "访问"
TaskMonitor --> Task : "控制"
DataStore --> Task : "存储"
Task --> TaskStatus : "使用"
```

**图表来源**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [DataStore.py](file://src/backEnd/model/DataStore.py)
- [Task.py](file://src/backEnd/model/Task.py)
- [TaskStatus.py](file://src/backEnd/model/TaskStatus.py)

#### 监控流程图
```mermaid
flowchart TD
Start([开始]) --> GetMaxTasks["获取最大任务数"]
GetMaxTasks --> CheckFirstRun{"首次运行?"}
CheckFirstRun --> |是| UseConfig["使用配置值"]
CheckFirstRun --> |否| CalculateDynamic["动态计算"]
UseConfig --> SetMaxTasks
CalculateDynamic --> SetMaxTasks["设置最大任务数"]
SetMaxTasks --> LockTasks["获取任务锁"]
LockTasks --> InitVars["初始化变量"]
InitVars --> LoopTasks["遍历所有任务"]
LoopTasks --> GetTask["获取任务"]
GetTask --> CheckStatus{"状态检查"}
CheckStatus --> |New/Runnable| AddRunnable["添加到可运行列表"]
AddRunnable --> ContinueLoop
CheckStatus --> |Running| CheckProcess["检查进程是否终止"]
CheckProcess --> |是| SetTerminated["设置为Terminated"]
SetTerminated --> ContinueLoop
CheckProcess --> |否| IncrementRunning["运行中任务数+1"]
IncrementRunning --> ContinueLoop
CheckStatus --> |Blocked| ContinueLoop
CheckStatus --> |Terminated| ContinueLoop
ContinueLoop --> MoreTasks{"还有任务?"}
MoreTasks --> |是| LoopTasks
MoreTasks --> |否| CheckCapacity["检查容量"]
CheckCapacity --> |运行中<最大数| StartRunnable["启动可运行任务"]
StartRunnable --> CheckDelay{"延迟1秒?"}
CheckDelay --> |是| StartTask["启动任务"]
StartTask --> SetRunning["设置为Running"]
SetRunning --> EndLoop
CheckDelay --> |否| SkipTask["跳过任务"]
SkipTask --> EndLoop
CheckCapacity --> |运行中>=最大数| EndLoop["结束循环"]
EndLoop --> End([结束])
```

**图表来源**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)

**章节来源**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)

### 监控服务初始化分析
监控服务的初始化过程包括配置Python路径、设置日志、初始化数据库和启动调度器。

#### 初始化序列图
```mermaid
sequenceDiagram
participant Main as "main.py"
participant Scheduler as "BackgroundScheduler"
participant Monitor as "monitor函数"
participant Database as "Database"
participant DataStore as "DataStore"
Main->>Main : 配置Python路径
Main->>Main : 导入模块
Main->>Main : 设置日志格式
Main->>Main : 生成管理员令牌
Main->>Database : 创建临时数据库文件
Database-->>Main : 返回文件路径
Main->>DataStore : 初始化数据库实例
DataStore->>Database : 连接数据库
DataStore->>Database : 初始化表结构
Database-->>DataStore : 初始化完成
DataStore-->>Main : 数据库准备就绪
Main->>Scheduler : 创建后台调度器
Scheduler->>Scheduler : 添加监控任务
Scheduler->>Monitor : 每3秒执行一次
Monitor-->>Scheduler : 执行完成
Scheduler->>Scheduler : 继续调度
Main->>Main : 启动Uvicorn服务器
```

**图表来源**
- [main.py](file://src/backEnd/main.py)

**章节来源**
- [main.py](file://src/backEnd/main.py)

## 依赖分析
系统各组件之间存在明确的依赖关系，形成了清晰的调用链。

```mermaid
graph TD
main[main.py] --> task_monitor[task_monitor.py]
main --> config[config.py]
task_monitor --> DataStore[DataStore.py]
task_monitor --> Task[Task.py]
task_monitor --> TaskStatus[TaskStatus.py]
task_monitor --> psutil[psutil]
task_monitor --> os[os]
taskService[taskService.py] --> DataStore
taskService --> Task
taskService --> TaskStatus
Task --> Database[Database.py]
Task --> HeaderRuleService[headerRuleService.py]
Task --> header_processor[header_processor.py]
Task --> session_header_manager[session_header_manager.py]
```

**图表来源**
- [main.py](file://src/backEnd/main.py)
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [taskService.py](file://src/backEnd/service/taskService.py)

**章节来源**
- [main.py](file://src/backEnd/main.py)
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [taskService.py](file://src/backEnd/service/taskService.py)

## 性能考虑
系统在设计时充分考虑了性能因素，通过多种机制确保高效运行。

### 性能指标采集
系统采集以下关键性能指标：
- **任务执行时间**：通过`start_datetime`字段记录任务开始时间
- **CPU占用率**：使用`psutil.cpu_percent()`获取系统CPU使用率
- **内存使用**：通过`psutil`库监控内存消耗
- **任务并发数**：通过`max_tasks_count`控制最大并发任务数

### 动态负载调整
系统根据当前CPU使用率动态调整最大任务数：
- CPU使用率<20%：最大任务数=逻辑核心数×2
- CPU使用率<50%：最大任务数=逻辑核心数
- CPU使用率≥50%：最大任务数=逻辑核心数//2（至少为1）

### 性能优化策略
1. **线程安全**：使用`threading.Lock`保护共享数据
2. **延迟启动**：新任务延迟1秒启动，避免瞬间高负载
3. **资源监控**：实时监控系统资源，动态调整任务调度
4. **连接池**：使用有序字典存储任务，提高查找效率

**章节来源**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [DataStore.py](file://src/backEnd/model/DataStore.py)

## 故障排除指南
为运维人员提供以下故障排除和性能诊断指南：

### 监控数据解读
- **任务状态**：New→Runnable→Running→Terminated是正常生命周期
- **CPU使用率**：持续高于80%可能需要增加服务器资源
- **内存消耗**：异常增长可能表明存在内存泄漏
- **任务队列**：长时间积压可能表明并发数设置过低

### 异常模式识别
1. **任务卡死**：任务状态长时间为Running但无进展
   - 检查：`engine_has_terminated()`返回False但无输出
   - 解决：手动终止任务或重启服务

2. **资源耗尽**：CPU或内存持续高占用
   - 检查：`psutil`监控数据
   - 解决：降低`max_tasks_count`或优化任务配置

3. **数据库连接问题**：任务无法写入日志
   - 检查：`DataStore.current_db`是否为None
   - 解决：检查数据库文件权限和磁盘空间

### 容量规划建议
1. **初始配置**：根据服务器CPU核心数设置初始并发数
2. **压力测试**：逐步增加并发任务，观察系统响应
3. **监控告警**：设置CPU、内存使用率阈值告警
4. **弹性扩展**：根据业务需求动态调整最大任务数

5. **性能基准**：建立正常运行时的性能基线，便于异常检测

**章节来源**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [taskService.py](file://src/backEnd/service/taskService.py)
- [DataStore.py](file://src/backEnd/model/DataStore.py)

## 结论
本文档详细解析了SQLMapWebUI系统的监控机制。系统通过APScheduler实现定时监控，采用动态负载调整策略优化资源利用，提供了完整的任务生命周期管理。监控服务初始化流程清晰，性能指标采集全面，为系统稳定运行提供了有力保障。运维人员可根据本文档提供的指南进行性能调优和故障排除，确保系统高效稳定运行。