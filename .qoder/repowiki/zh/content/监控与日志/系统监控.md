# 系统监控

<cite>
**本文档引用的文件**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [main.py](file://src/backEnd/main.py)
- [config.py](file://src/backEnd/config.py)
- [DataStore.py](file://src/backEnd/model/DataStore.py)
- [Task.py](file://src/backEnd/model/Task.py)
- [TaskStatus.py](file://src/backEnd/model/TaskStatus.py)
- [taskService.py](file://src/backEnd/service/taskService.py)
- [useSmartPolling.ts](file://src/frontEnd/src/utils/useSmartPolling.ts) - *新增于最近提交*
- [OfflineBanner.vue](file://src/frontEnd/src/components/OfflineBanner.vue) - *新增于最近提交*
- [auth.ts](file://src/frontEnd/src/stores/auth.ts) - *新增健康检查功能*
</cite>

## 更新摘要
**已更新内容**
- 在“架构概述”部分增加了前端智能轮询机制的说明
- 新增“前端监控机制”章节，详细说明健康检查和离线提示功能
- 更新“故障排除指南”，增加前端监控相关的诊断建议
- 在“依赖分析”中增加了前端组件的依赖关系

**新增内容**
- 新增“前端监控机制”章节，包含智能轮询和离线提示功能的详细说明
- 新增前端健康检查流程图
- 新增前端监控组件类图

**文档来源更新**
- 增加了前端相关文件的引用，包括useSmartPolling.ts、OfflineBanner.vue和auth.ts
- 更新了受影响的章节来源信息

## 目录
1. [简介](#简介)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [架构概述](#架构概述)
5. [详细组件分析](#详细组件分析)
6. [前端监控机制](#前端监控机制)
7. [依赖分析](#依赖分析)
8. [性能考虑](#性能考虑)
9. [故障排除指南](#故障排除指南)
10. [结论](#结论)

## 简介
本文档详细解析了SQLMapWebUI项目中的系统监控机制。重点分析了任务监控器的实现原理，包括监控循环的调度、任务状态轮询逻辑以及自动处理策略。文档还说明了监控服务的初始化流程、关键性能指标的采集方法、系统的可配置性以及为运维人员提供的实用诊断指南。本次更新特别增加了前端监控机制的详细说明，包括智能轮询策略和离线提示功能。

## 项目结构
项目采用分层架构，主要模块包括API接口、模型定义、服务逻辑和工具函数。监控相关的核心文件位于`utils`目录下的`task_monitor.py`，监控服务的初始化在`main.py`中完成。前端监控功能实现在`src/frontEnd/src/utils`和`src/frontEnd/src/components`目录下。

```mermaid
graph TD
subgraph "src/backEnd"
subgraph "utils"
task_monitor[task_monitor.py]
auth[auth.py]
header_processor[header_processor.py]
session_header_manager[session_header_manager.py]
end
subgraph "model"
DataStore[DataStore.py]
Task[Task.py]
TaskStatus[TaskStatus.py]
Database[Database.py]
end
subgraph "service"
taskService[taskService.py]
headerRuleService[headerRuleService.py]
end
main[main.py]
app[app.py]
config[config.py]
subgraph "third_lib"
sqlmap[sqlmap]
end
end
subgraph "src/frontEnd"
subgraph "utils"
useSmartPolling[useSmartPolling.ts]
end
subgraph "components"
OfflineBanner[OfflineBanner.vue]
end
subgraph "stores"
authStore[auth.ts]
end
end
main --> task_monitor
main --> config
task_monitor --> DataStore
task_monitor --> Task
task_monitor --> TaskStatus
taskService --> DataStore
taskService --> Task
taskService --> TaskStatus
useSmartPolling --> authStore
OfflineBanner --> authStore
```

**图表来源**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [main.py](file://src/backEnd/main.py)
- [DataStore.py](file://src/backEnd/model/DataStore.py)
- [useSmartPolling.ts](file://src/frontEnd/src/utils/useSmartPolling.ts)
- [OfflineBanner.vue](file://src/frontEnd/src/components/OfflineBanner.vue)
- [auth.ts](file://src/frontEnd/src/stores/auth.ts)

**章节来源**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [main.py](file://src/backEnd/main.py)
- [useSmartPolling.ts](file://src/frontEnd/src/utils/useSmartPolling.ts)
- [OfflineBanner.vue](file://src/frontEnd/src/components/OfflineBanner.vue)

## 核心组件
系统监控的核心组件包括任务监控器、任务状态管理器、任务服务以及新增的前端监控组件。任务监控器负责定期检查任务状态并启动可运行的任务，任务状态管理器定义了任务的生命周期，任务服务提供了对任务的增删改查操作。前端新增了智能轮询和离线提示组件，增强了用户体验。

**章节来源**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [Task.py](file://src/backEnd/model/Task.py)
- [TaskStatus.py](file://src/backEnd/model/TaskStatus.py)
- [useSmartPolling.ts](file://src/frontEnd/src/utils/useSmartPolling.ts)
- [OfflineBanner.vue](file://src/frontEnd/src/components/OfflineBanner.vue)

## 架构概述
系统采用基于APScheduler的定时任务监控架构，通过后台调度器定期执行监控函数。监控函数检查任务队列中的任务状态，根据系统负载动态调整最大并发任务数，并启动符合条件的任务。前端新增了智能轮询机制，通过健康检查端点监控后端服务状态，并在服务不可用时向用户展示离线提示。

```mermaid
sequenceDiagram
participant Scheduler as "APScheduler"
participant Monitor as "任务监控器"
participant DataStore as "数据存储"
participant Task as "任务"
participant Frontend as "前端"
participant HealthCheck as "健康检查"
Scheduler->>Monitor : 每3秒执行一次
Monitor->>DataStore : 获取任务锁
Monitor->>DataStore : 获取最大任务数
Monitor->>DataStore : 遍历所有任务
loop 任务状态检查
DataStore->>Task : 获取任务状态
alt 任务可运行
Task->>Monitor : 添加到可运行列表
else 任务正在运行
Task->>Monitor : 检查进程是否终止
alt 进程已终止
Task->>Task : 状态设为Terminated
end
end
end
Monitor->>Monitor : 检查运行中任务数
alt 有空闲容量
loop 启动可运行任务
Monitor->>Task : 启动任务
Task->>Task : 设置状态为Running
end
end
Frontend->>HealthCheck : 定期检查后端健康状态
HealthCheck-->>Frontend : 返回健康状态
alt 后端不健康
Frontend->>Frontend : 显示离线提示
end
```

**图表来源**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [main.py](file://src/backEnd/main.py)
- [useSmartPolling.ts](file://src/frontEnd/src/utils/useSmartPolling.ts)
- [auth.ts](file://src/frontEnd/src/stores/auth.ts)

## 详细组件分析

### 任务监控器分析
任务监控器是系统监控的核心，负责任务的调度和状态管理。

#### 任务监控类图
```mermaid
classDiagram
class TaskMonitor {
+monitor(max_tasks_count)
+get_max_tasks_count()
}
class DataStore {
+tasks : OrderedDict
+tasks_lock : Lock
+max_tasks_count : int
+max_tasks_count_lock : Lock
+first_checkin_monitor : bool
+get_session_header_manager()
}
class Task {
+status : TaskStatus
+start_datetime : datetime
+taskid : str
+scanUrl : str
+host : str
+headers : list
+body : str
+remote_addr : str
+process : Popen
+options : AttribDict
+_header_rules_applied : bool
+engine_start()
+engine_stop()
+engine_kill()
+engine_has_terminated()
+apply_header_rules()
}
class TaskStatus {
+New : "New"
+Runnable : "Runnable"
+Running : "Running"
+Blocked : "Blocked"
+Terminated : "Terminated"
}
TaskMonitor --> DataStore : "访问"
TaskMonitor --> Task : "控制"
DataStore --> Task : "存储"
Task --> TaskStatus : "使用"
```

**图表来源**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [DataStore.py](file://src/backEnd/model/DataStore.py)
- [Task.py](file://src/backEnd/model/Task.py)
- [TaskStatus.py](file://src/backEnd/model/TaskStatus.py)

#### 监控流程图
```mermaid
flowchart TD
Start([开始]) --> GetMaxTasks["获取最大任务数"]
GetMaxTasks --> CheckFirstRun{"首次运行?"}
CheckFirstRun --> |是| UseConfig["使用配置值"]
CheckFirstRun --> |否| CalculateDynamic["动态计算"]
UseConfig --> SetMaxTasks
CalculateDynamic --> SetMaxTasks["设置最大任务数"]
SetMaxTasks --> LockTasks["获取任务锁"]
LockTasks --> InitVars["初始化变量"]
InitVars --> LoopTasks["遍历所有任务"]
LoopTasks --> GetTask["获取任务"]
GetTask --> CheckStatus{"状态检查"}
CheckStatus --> |New/Runnable| AddRunnable["添加到可运行列表"]
AddRunnable --> ContinueLoop
CheckStatus --> |Running| CheckProcess["检查进程是否终止"]
CheckProcess --> |是| SetTerminated["设置为Terminated"]
SetTerminated --> ContinueLoop
CheckProcess --> |否| IncrementRunning["运行中任务数+1"]
IncrementRunning --> ContinueLoop
CheckStatus --> |Blocked| ContinueLoop
CheckStatus --> |Terminated| ContinueLoop
ContinueLoop --> MoreTasks{"还有任务?"}
MoreTasks --> |是| LoopTasks
MoreTasks --> |否| CheckCapacity["检查容量"]
CheckCapacity --> |运行中<最大数| StartRunnable["启动可运行任务"]
StartRunnable --> CheckDelay{"延迟1秒?"}
CheckDelay --> |是| StartTask["启动任务"]
StartTask --> SetRunning["设置为Running"]
SetRunning --> EndLoop
CheckDelay --> |否| SkipTask["跳过任务"]
SkipTask --> EndLoop
CheckCapacity --> |运行中>=最大数| EndLoop["结束循环"]
EndLoop --> End([结束])
```

**图表来源**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)

**章节来源**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)

### 监控服务初始化分析
监控服务的初始化过程包括配置Python路径、设置日志、初始化数据库和启动调度器。

#### 初始化序列图
```mermaid
sequenceDiagram
participant Main as "main.py"
participant Scheduler as "BackgroundScheduler"
participant Monitor as "monitor函数"
participant Database as "Database"
participant DataStore as "DataStore"
Main->>Main : 配置Python路径
Main->>Main : 导入模块
Main->>Main : 设置日志格式
Main->>Main : 生成管理员令牌
Main->>Database : 创建临时数据库文件
Database-->>Main : 返回文件路径
Main->>DataStore : 初始化数据库实例
DataStore->>Database : 连接数据库
DataStore->>Database : 初始化表结构
Database-->>DataStore : 初始化完成
DataStore-->>Main : 数据库准备就绪
Main->>Scheduler : 创建后台调度器
Scheduler->>Scheduler : 添加监控任务
Scheduler->>Monitor : 每3秒执行一次
Monitor-->>Scheduler : 执行完成
Scheduler->>Scheduler : 继续调度
Main->>Main : 启动Uvicorn服务器
```

**图表来源**
- [main.py](file://src/backEnd/main.py)

**章节来源**
- [main.py](file://src/backEnd/main.py)

## 前端监控机制
前端新增了智能轮询和离线提示功能，增强了系统的主动监控能力和用户体验。

### 智能轮询策略
前端实现了智能轮询Hook，支持页面可见性监听、网络状态监听和健康检查。

#### 智能轮询类图
```mermaid
classDiagram
class useSmartPolling {
+callback : () => Promise<void> | void
+interval : number
+backgroundInterval : number
+pauseOnUnhealthy : boolean
+immediate : boolean
+isPolling : boolean
+isPageVisible : boolean
+isOnline : boolean
+startPolling()
+stopPolling()
+restartPolling()
+getCurrentInterval()
+shouldPoll()
+executePoll()
+handleVisibilityChange()
+handleOnlineStatusChange()
}
class authStore {
+token : string | null
+userInfo : UserInfo | null
+isLocalMode : boolean
+authRequired : boolean
+backendHealthy : boolean
+lastHealthCheck : number
+isLoggedIn : boolean
+userName : string
+needAuth : boolean
+login()
+logout()
+checkAuth()
+initAuth()
+checkBackendHealth()
+resetHealthCheck()
}
useSmartPolling --> authStore : "依赖"
```

**图表来源**
- [useSmartPolling.ts](file://src/frontEnd/src/utils/useSmartPolling.ts)
- [auth.ts](file://src/frontEnd/src/stores/auth.ts)

#### 智能轮询流程图
```mermaid
flowchart TD
Start([开始]) --> Init["初始化"]
Init --> ListenVisibility["监听页面可见性"]
Init --> ListenNetwork["监听网络状态"]
Init --> StartPolling["启动轮询"]
StartPolling --> CheckCondition["检查轮询条件"]
CheckCondition --> |离线| PausePolling["暂停轮询"]
CheckCondition --> |后端不健康| PausePolling
CheckCondition --> |正常| ExecuteCallback["执行回调"]
ExecuteCallback --> SetTimer["设置定时器"]
SetTimer --> CheckVisibility{"页面可见?"}
CheckVisibility --> |是| NormalInterval["正常间隔"]
CheckVisibility --> |否| BackgroundInterval["后台间隔"]
NormalInterval --> Timer
BackgroundInterval --> Timer
Timer([定时器]) --> Wait["等待"]
Wait --> Trigger["触发"]
Trigger --> CheckCondition
ListenVisibility --> HandleVisibility["处理可见性变化"]
HandleVisibility --> |页面可见| RestartNormal["重启正常轮询"]
HandleVisibility --> |页面隐藏| RestartBackground["重启后台轮询"]
ListenNetwork --> HandleNetwork["处理网络变化"]
HandleNetwork --> |网络恢复| CheckHealth["检查后端健康"]
HandleNetwork --> |网络离线| StopPolling["停止轮询"]
CheckHealth --> RestartPolling["重启轮询"]
```

**图表来源**
- [useSmartPolling.ts](file://src/frontEnd/src/utils/useSmartPolling.ts)

**章节来源**
- [useSmartPolling.ts](file://src/frontEnd/src/utils/useSmartPolling.ts)

### 离线提示功能
当健康检查失败或网络离线时，系统会向用户展示离线提示。

#### 离线提示流程图
```mermaid
flowchart TD
Start([开始]) --> CheckStatus["检查状态"]
CheckStatus --> |网络离线| ShowOffline["显示离线提示"]
CheckStatus --> |后端不健康| ShowBackendError["显示后端错误"]
CheckStatus --> |正常| HideBanner["隐藏提示"]
ShowOffline --> Message1["您当前处于离线状态，部分功能不可用"]
ShowBackendError --> Message2["无法连接到后端服务，请检查服务是否已启动"]
Message1 --> Display["显示提示"]
Message2 --> Display
Display --> ListenEvents["监听事件"]
ListenEvents --> |网络恢复| CheckBackend["检查后端健康"]
ListenEvents --> |后端恢复| HideBanner
CheckBackend --> |健康| HideBanner
CheckBackend --> |不健康| ContinueShow["继续显示"]
HideBanner --> End([结束])
```

**图表来源**
- [OfflineBanner.vue](file://src/frontEnd/src/components/OfflineBanner.vue)
- [auth.ts](file://src/frontEnd/src/stores/auth.ts)

**章节来源**
- [OfflineBanner.vue](file://src/frontEnd/src/components/OfflineBanner.vue)

## 依赖分析
系统各组件之间存在明确的依赖关系，形成了清晰的调用链。

```mermaid
graph TD
main[main.py] --> task_monitor[task_monitor.py]
main --> config[config.py]
task_monitor --> DataStore[DataStore.py]
task_monitor --> Task[Task.py]
task_monitor --> TaskStatus[TaskStatus.py]
task_monitor --> psutil[psutil]
task_monitor --> os[os]
taskService[taskService.py] --> DataStore
taskService --> Task
taskService --> TaskStatus
Task --> Database[Database.py]
Task --> HeaderRuleService[headerRuleService.py]
Task --> header_processor[header_processor.py]
Task --> session_header_manager[session_header_manager.py]
useSmartPolling[useSmartPolling.ts] --> authStore[auth.ts]
OfflineBanner[OfflineBanner.vue] --> authStore[auth.ts]
authStore[auth.ts] --> request[request.ts]
authStore[auth.ts] --> storage[storage.ts]
```

**图表来源**
- [main.py](file://src/backEnd/main.py)
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [taskService.py](file://src/backEnd/service/taskService.py)
- [useSmartPolling.ts](file://src/frontEnd/src/utils/useSmartPolling.ts)
- [OfflineBanner.vue](file://src/frontEnd/src/components/OfflineBanner.vue)
- [auth.ts](file://src/frontEnd/src/stores/auth.ts)

**章节来源**
- [main.py](file://src/backEnd/main.py)
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [taskService.py](file://src/backEnd/service/taskService.py)
- [useSmartPolling.ts](file://src/frontEnd/src/utils/useSmartPolling.ts)
- [OfflineBanner.vue](file://src/frontEnd/src/components/OfflineBanner.vue)

## 性能考虑
系统在设计时充分考虑了性能因素，通过多种机制确保高效运行。

### 性能指标采集
系统采集以下关键性能指标：
- **任务执行时间**：通过`start_datetime`字段记录任务开始时间
- **CPU占用率**：使用`psutil.cpu_percent()`获取系统CPU使用率
- **内存使用**：通过`psutil`库监控内存消耗
- **任务并发数**：通过`max_tasks_count`控制最大并发任务数

### 动态负载调整
系统根据当前CPU使用率动态调整最大任务数：
- CPU使用率<20%：最大任务数=逻辑核心数×2
- CPU使用率<50%：最大任务数=逻辑核心数
- CPU使用率≥50%：最大任务数=逻辑核心数//2（至少为1）

### 性能优化策略
1. **线程安全**：使用`threading.Lock`保护共享数据
2. **延迟启动**：新任务延迟1秒启动，避免瞬间高负载
3. **资源监控**：实时监控系统资源，动态调整任务调度
4. **连接池**：使用有序字典存储任务，提高查找效率
5. **智能轮询**：根据页面可见性和网络状态调整轮询频率，减少不必要的请求

**章节来源**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [DataStore.py](file://src/backEnd/model/DataStore.py)
- [useSmartPolling.ts](file://src/frontEnd/src/utils/useSmartPolling.ts)

## 故障排除指南
为运维人员提供以下故障排除和性能诊断指南：

### 监控数据解读
- **任务状态**：New→Runnable→Running→Terminated是正常生命周期
- **CPU使用率**：持续高于80%可能需要增加服务器资源
- **内存消耗**：异常增长可能表明存在内存泄漏
- **任务队列**：长时间积压可能表明并发数设置过低
- **前端健康检查**：频繁的健康检查失败可能表明后端服务不稳定

### 异常模式识别
1. **任务卡死**：任务状态长时间为Running但无进展
   - 检查：`engine_has_terminated()`返回False但无输出
   - 解决：手动终止任务或重启服务

2. **资源耗尽**：CPU或内存持续高占用
   - 检查：`psutil`监控数据
   - 解决：降低`max_tasks_count`或优化任务配置

3. **数据库连接问题**：任务无法写入日志
   - 检查：`DataStore.current_db`是否为None
   - 解决：检查数据库文件权限和磁盘空间

4. **前端离线提示**：用户频繁看到离线提示
   - 检查：后端健康检查接口响应时间和成功率
   - 解决：优化后端服务性能或调整健康检查超时设置

### 容量规划建议
1. **初始配置**：根据服务器CPU核心数设置初始并发数
2. **压力测试**：逐步增加并发任务，观察系统响应
3. **监控告警**：设置CPU、内存使用率阈值告警
4. **弹性扩展**：根据业务需求动态调整最大任务数
5. **性能基准**：建立正常运行时的性能基线，便于异常检测
6. **健康检查优化**：合理设置健康检查间隔，避免对后端造成过大压力

**章节来源**
- [task_monitor.py](file://src/backEnd/utils/task_monitor.py)
- [taskService.py](file://src/backEnd/service/taskService.py)
- [DataStore.py](file://src/backEnd/model/DataStore.py)
- [useSmartPolling.ts](file://src/frontEnd/src/utils/useSmartPolling.ts)
- [OfflineBanner.vue](file://src/frontEnd/src/components/OfflineBanner.vue)

## 结论
本文档详细解析了SQLMapWebUI系统的监控机制。系统通过APScheduler实现定时监控，采用动态负载调整策略优化资源利用，提供了完整的任务生命周期管理。监控服务初始化流程清晰，性能指标采集全面，为系统稳定运行提供了有力保障。新增的前端智能轮询和离线提示功能，显著提升了用户体验和系统的可观测性。运维人员可根据本文档提供的指南进行性能调优和故障排除，确保系统高效稳定运行。